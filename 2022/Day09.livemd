# Advent of Code: Day 09

## Helpers

```elixir
defmodule Helpers do
  @spec read_file_contents(String.t()) :: binary()
  def read_file_contents(filename) do
    file_path = "/Users/charlie/github.com/charlieroth/advent-of-code/2022/#{filename}"

    case File.read(file_path) do
      {:ok, contents} -> contents
      {:error, _} -> raise("Failed to read file contents")
    end
  end
end
```

## Part 01

You just need to work out where the tail goes as the head follows a series of motions. Assume the head and the tail both start at the same position, overlapping.

For example:

```
R 4
U 4
L 3
D 1
R 4
D 1
L 5
R 2
```

This series of motions moves the head `right` four steps, then `up` four steps, then `left` three steps, then `down` one step, and so on. After each step, you'll need to update the position of the tail if the step means the head is no longer adjacent to the tail. Visually, these motions occur as follows (`s` marks the starting position as a reference point):

```
== Initial State ==

......
......
......
......
H.....  (H covers T, s)

== R 4 ==

......
......
......
......
TH....  (T covers s)

......
......
......
......
sTH...

......
......
......
......
s.TH..

......
......
......
......
s..TH.

== U 4 ==

......
......
......
....H.
s..T..

......
......
....H.
....T.
s.....

......
....H.
....T.
......
s.....

....H.
....T.
......
......
s.....

== L 3 ==

...H..
....T.
......
......
s.....

..HT..
......
......
......
s.....

.HT...
......
......
......
s.....

== D 1 ==

..T...
.H....
......
......
s.....

== R 4 ==

..T...
..H...
......
......
s.....

..T...
...H..
......
......
s.....

......
...TH.
......
......
s.....

......
....TH
......
......
s.....

== D 1 ==

......
....T.
.....H
......
s.....

== L 5 ==

......
....T.
....H.
......
s.....

......
....T.
...H..
......
s.....

......
......
..HT..
......
s.....

......
......
.HT...
......
s.....

......
......
HT....
......
s.....

== R 2 ==

......
......
.H....  (H covers T)
......
s.....

......
......
.TH...
......
s.....
```

```elixir
defmodule PartOne do
  def solution(input) do
    all_positions_visited =
      input
      |> parse()
      |> process_instructions()
      |> deduplicate()
      |> length()

    # subtract 1 b/c starting position is {0, 0}
    all_positions_visited - 1
  end

  defp parse(input) do
    input
    |> String.split("\n", trim: true)
    |> Enum.map(&String.split(&1, " ", trim: true))
    |> Enum.flat_map(fn [direction, units] ->
      u = String.to_integer(units)
      Enum.map(1..u, fn _ -> {direction, 1} end)
    end)
  end

  defp process_instructions(instructions) do
    Enum.reduce(instructions, %{head: {0, 0}, tail: {0, 0}, visited: []}, &process_instruction/2)
  end

  defp deduplicate(%{visited: visited} = _state) do
    Enum.dedup(visited)
  end

  defp process_instruction(instruction, %{head: {hx, hy}, tail: tail, visited: visited} = state) do
    case instruction do
      {"R", units} ->
        h = {hx + units, hy}
        t = move_tail(h, tail)
        %{state | head: h, tail: t, visited: [t | visited]}

      {"L", units} ->
        h = {hx - units, hy}
        t = move_tail(h, tail)
        %{state | head: h, tail: t, visited: [t | visited]}

      {"U", units} ->
        h = {hx, hy + units}
        t = move_tail(h, tail)
        %{state | head: h, tail: t, visited: [t | visited]}

      {"D", units} ->
        h = {hx, hy - units}
        t = move_tail(h, tail)
        %{state | head: h, tail: t, visited: [t | visited]}
    end
  end

  defp move_tail({hx, hy}, {tx, ty}) when abs(hx - tx) <= 1 and abs(hy - ty) <= 1, do: {tx, ty}
  defp move_tail({tx, hy}, {tx, ty}) when hy - ty > 0, do: {tx, ty + 1}
  defp move_tail({tx, hy}, {tx, ty}) when hy - ty < 0, do: {tx, ty - 1}
  defp move_tail({hx, ty}, {tx, ty}) when hx - tx > 0, do: {tx + 1, ty}
  defp move_tail({hx, ty}, {tx, ty}) when hx - tx < 0, do: {tx - 1, ty}

  defp move_tail({hx, hy}, {tx, ty}) do
    dx = if hx - tx > 0, do: 1, else: -1
    dy = if hy - ty > 0, do: 1, else: -1
    {tx + dx, ty + dy}
  end
end

Helpers.read_file_contents("inputs/Day09.txt")
|> PartOne.solution()
```

## Part 02

TODO

```elixir
"Part 02"
```
